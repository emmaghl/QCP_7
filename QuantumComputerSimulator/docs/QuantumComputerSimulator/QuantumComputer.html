<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>QuantumComputerSimulator.QuantumComputer API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>QuantumComputerSimulator.QuantumComputer</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from QuantumComputerSimulator.mods.PrintingCircuit import PrintingCircuit
from QuantumComputerSimulator.mods.DenseMatrix import DenseMatrix
from QuantumComputerSimulator.mods.SparseMatrix import SparseMatrix
from QuantumComputerSimulator.mods.LazyMatrix import LazyMatrix
from QuantumComputerSimulator.mods.LazyMatrixSingle import LazyMatrixSingle
from QuantumComputerSimulator.mods.MatrixFrame import MatrixFrame
from QuantumComputerSimulator.mods.check import check

import numpy as np
from abc import ABC
import random

class QuantumComputer(ABC):

    def __init__(self, qubits: int, matrix_type:str = &#34;Dense&#34;):
        &#39;&#39;&#39;
        Simulates quantum circuits via Dense, Sparse and Lazy methods.

        &lt;b&gt;qubits&lt;/b&gt; Number of qubits in the circuit.&lt;br&gt;
        &lt;b&gt;matrix_type&lt;/b&gt; Desired implementation of quantum computer to use. Default is Dense.
        &#39;&#39;&#39;

        check.check_type(qubits, int)
        self.N = qubits

        check.check_type(matrix_type, str)
        check.check_in_list(matrix_type, [&#34;Dense&#34;, &#34;Sparse&#34;, &#34;Lazy&#34;, &#34;LazySingle&#34;])

        &#39;&#39;&#39;
        Take desired method: Dense, Sparse or Lazy; and set the quantum computer to use that method.
        &#39;&#39;&#39;
        if matrix_type == &#34;Dense&#34;:
            self.Matrix = DenseMatrix
        if matrix_type == &#34;Sparse&#34;:
            self.Matrix = SparseMatrix
        if matrix_type == &#34;Lazy&#34;:
            self.Matrix = LazyMatrix
        if matrix_type == &#34;LazySingle&#34;:
            self.Matrix = LazyMatrixSingle

        &#39;&#39;&#39;
        Build the different gates using the desired method. Gate building is handled within the matrix method.
        &#39;&#39;&#39;
        # single input gates
        self.I = self.Matrix(&#39;I&#39;)
        self.H = self.Matrix(&#39;H&#39;)
        self.P = lambda theta: self.Matrix(&#39;P&#39;, theta)
        self.X = self.Matrix(&#39;X&#39;)
        self.Y = self.Matrix(&#39;Y&#39;)
        self.Z = self.Matrix(&#39;Z&#39;)
        # How does single_gate deal with the extra argument required for P?

        # measuring gates
        self.M0 = self.Matrix(&#39;M0&#39;)
        self.M1 = self.Matrix(&#39;M1&#39;)

        # produce binary digits for 2 input gate logic
        self.binary = self.__produce_digits()

        # gate inputs
        self.single_inputs = [&#34;H&#34;, &#34;P&#34;, &#34;X&#34;, &#34;Y&#34;, &#34;Z&#34;, &#34;M0&#34;, &#34;M1&#34;]
        self.matrices = [self.H, self.P, self.X, self.Y, self.Z, self.M0, self.M1]

        self.double_inputs = [&#34;CV&#34;, &#34;CNOT&#34;, &#34;CZ&#34;]

        #Initalise empty list to store history of gates used.
        self.__gate_history = []
        self.__custom_gate_names = []
        self.circuit = MatrixFrame

    def print_circuit(self):
        &#39;&#39;&#39;
        Prints the circuit that is built from using `add_gate_to_circuit` function.

        WARNING: Need to call `print_circuit_ascii` from terminal/cmd and will clear the terminal screen.
            Prints the quantum circuit in an ascii format on the terminal.
        &#39;&#39;&#39;
        pc = PrintingCircuit(self.__gate_history, self.N, custom_gate_names=self.__custom_gate_names)
        pc.print_circuit_ascii()

    def __produce_digits(self):  # this is the flipped basis, working on
        &#39;&#39;&#39;
        This produces the binary basis needed for the register.
        &#39;&#39;&#39;
        digits = []
        for i in range(0, 2 ** self.N):
            digit = []
            if i &lt; (2 ** self.N) / 2:
                digit.append(0)
            else:
                digit.insert(0, 1)
            for j in range(1, self.N):
                x = i
                for k in range(0, len(digit)):
                    x -= digit[k] * (2 ** self.N) / (2 ** (k + 1))
                if x &lt; (2 ** self.N) / (2 ** (j + 1)):
                    digit.append(0)
                else:
                    digit.append(1)
            digits.append(digit)
        digits = np.flip(digits, axis=1)
        return digits

    def __single_gates(self, gate: list, qnum: list) -&gt; MatrixFrame:
        &#39;&#39;&#39;
        Build the single input gates to a 2^N matrix where N is the number of Qubits.

        &lt;b&gt;gate&lt;/b&gt; A list of gates to build. &lt;br&gt;
        &lt;b&gt;qnum&lt;/b&gt; List of the number of qubits corresponding to each gate.&lt;br&gt;
        &lt;b&gt;return&lt;/b&gt; A gate as the specified matrix object.
        &#39;&#39;&#39;
        M = [0] * self.N

        for i in range(0, len(self.single_inputs)):
            for j in range(0, len(gate)):
                if self.single_inputs[i] == gate[j]:
                    for k in range(0, len(qnum[j])):
                        if gate[j] == &#34;P&#34;:
                            pass
                        else:
                            M[qnum[j][k]] = self.matrices[i]

        for i in range(0, len(M)):
            if type(M[i]) != np.ndarray and type(M[i]) != self.Matrix:
                M[i] = self.I

        m = M[0]
        for i in range(1, len(M)):
            m = self.Matrix.tensor_prod(m, M[i])

        return m

    def __double_gates(self, gate: list, qnum: list) -&gt; MatrixFrame:
        &#39;&#39;&#39;
        Use the Matrix method in the given desired method to build a multi-input gate.

        &lt;b&gt;gate&lt;/b&gt; A list with one elemnt being the double gate. &lt;br&gt;
        &lt;b&gt;qnum&lt;/b&gt; Qubit list. &lt;br&gt;
        &lt;b&gt;return&lt;/b&gt; Returns correctly sized multi-input gate.
        &#39;&#39;&#39;
        if gate[0] == &#34;CV&#34;:
            return self.Matrix(&#34;CV&#34;, self.binary, qnum[0][0], qnum[0][1])
        if gate[0] == &#34;CNOT&#34;:
            return self.Matrix(&#34;CNOT&#34;, self.binary, qnum[0][0], qnum[0][1])
        if gate[0] == &#34;CZ&#34;:
            return self.Matrix(&#34;CZ&#34;, self.binary, qnum[0][0], qnum[0][1])

    def __validate_gate_logic_inputs(self, inputs: list):
        &#39;&#39;&#39;
        A custom check function to verify the list of time steps when the user is adding gates to the circuit.
        &#39;&#39;&#39;
        check.check_type(inputs, list)

        for time_step in inputs:
            check.check_type(time_step, tuple)
            check.check_array_length(time_step, 2)
            check.check_type(time_step[0], list)
            check.check_type(time_step[1], list)
            check.check_array_length(time_step[0], len(time_step[1]))
            for gate in time_step[0]: #Looping through gates, check to see they&#39;re recognisable.
                check.check_type(gate, str)
                check.check_in_list(gate, self.single_inputs + self.double_inputs)
            for gate_positions in time_step[1]:
                check.check_type(gate_positions, list)
                for numbers in gate_positions:
                    check.check_type(numbers, int)

    def gate_logic(self, inputs: list, add_gate_name: str = &#34;&#34;) -&gt; MatrixFrame:
        &#39;&#39;&#39;
        Builds the quantum circuit from a list of time steps. See README.md for examples of what to enter into the parameter `input`.

        &lt;b&gt;inputs&lt;/b&gt; List of time steps. &lt;br&gt;
        &lt;b&gt;add_gate_name&lt;/b&gt; Name of gates to be added. &lt;br&gt;
        &lt;b&gt;return&lt;/b&gt; The circuit of type determined from the instantiation of quantum computer.
        &#39;&#39;&#39;

        check.check_type(add_gate_name, str)
        self.__validate_gate_logic_inputs(inputs)

        step_n = len(inputs)

        M = []

        for i in range(0, step_n):
            gate_type = []
            for j in range(0, len(self.single_inputs)):
                if self.single_inputs[j] in inputs[i][0]:
                    gate_type.append(&#39;single&#39;)

            for j in range(0, len(self.double_inputs)):
                if self.double_inputs[j] in inputs[i][0]:
                    gate_type.append(&#39;double&#39;)

            gate_single = []
            gate_double = []
            for j in range(0, len(gate_type)):
                if gate_type[j] == &#39;single&#39;:
                    gate_single.append(True)
                else:
                    gate_single.append(False)
                if gate_type[j] == &#39;double&#39;:
                    gate_double.append(True)
                else:
                    gate_double.append(False)

            if all(gate_single) == True:
                M.append(self.__single_gates(inputs[i][0], inputs[i][1]))
            elif all(gate_double) == True:
                M.append(self.__double_gates(inputs[i][0], inputs[i][1]))
            else:
                print(
                    &#34;Input error: single gates and double gates must be in separate steps. Returning identity matrix instead.&#34;)
                return self.Matrix(&#39;I&#39;)

        M = np.flip(M, axis=0)
        m = M[0]
        for i in range(1, len(M)):
            m = self.Matrix.matrix_multiply(m, M[i])

        return m

    def measure_any(self, qnum: int, state: int, register: list) -&gt; int:
        &#39;&#39;&#39;
        Generate the measurement of the quantum circuit; once measured the system&#39;s wave function is collapsed.

        &lt;b&gt;qnum&lt;/b&gt; Number of qubits. &lt;br&gt;
        &lt;b&gt;state&lt;/b&gt; State of the qubit. &lt;br&gt;
        &lt;b&gt;state&lt;/b&gt; Result of the measurement of qubit qnum.
        &#39;&#39;&#39;
        check.check_type(qnum, int)
        check.check_type(state, int)
        check.check_type(register, list)

        inner_register = self.Matrix.inner_product(register)
        if state == 0:
            matrix = self.__single_gates([&#34;M0&#34;], [[qnum]])
        elif state == 1:
            matrix = self.__single_gates([&#34;M1&#34;], [[qnum]])

        QP = self.Matrix.trace(self.Matrix.matrix_multiply(matrix, inner_register))
        #print(&#39;QP= &#39;, QP)
        if (np.random.rand() &lt; QP):
            result = 0
        else:
            result = 1
        return result

    def apply_register_and_measure(self, repeats: int = 1000, user_input_vector: list = []) -&gt; dict:
        &#39;&#39;&#39;
        Apply&#39;s a register to the circuit built with `add_gate_to_circuit`, with default being the |0&gt; state in the computatinal basis.

        &lt;b&gt;repeats&lt;/b&gt; The number of measurements to be taken; assuming upon each measurement a new register is applied. &lt;br&gt;
        &lt;b&gt;user_input_vector&lt;/b&gt; Allows custom choice of a register. &lt;br&gt;
        &lt;b&gt;returns&lt;/b&gt; A dictionary of keys labelling the binary states, and the values the number of times that state was measured over.
        &#39;&#39;&#39;
        check.check_type(repeats, int)

        # Checks to see if user has defined their own register. If so, switch to theirs and validate
        input_vector = np.zeros(2**self.N)
        input_vector[0] = 1
        if not user_input_vector == []:
            check.check_type(user_input_vector, list)
            check.check_array_shape(user_input_vector, (2**self.N))
            check.check_sum(user_input_vector, 1.00) # Check normalisation.
            input_vector = user_input_vector

        probabilities = self.circuit.apply_register(input_vector) #Get probabilities from applying input vector

        binary_states = {}
        for i, basis in enumerate(self.binary):
            binary_states[&#39;&#39;.join([str(j) for j in basis[::-1]])] = 0 # Creates the binary label, such as 001 for |001&gt;.


        keys_list = list(binary_states.keys())
        for _ in range(repeats): # Repeats the measurements a number of times
            cumulative = 0
            skip = False
            j = 0
            random_var = random.random()
            while (not skip) and j &lt; len(probabilities): # From random number between 0 and 1, finds the component of the vector by cummulative probability.
                cumulative += probabilities[j]
                if cumulative &gt; random_var:
                    binary_states[keys_list[j]] += 1
                    skip = True
                j += 1

        return binary_states

    def add_gate_to_circuit(self, inputs: list, add_gate_name:str = &#34;&#34;):
        &#39;&#39;&#39;
        Adds the gates to the class ready to for building the circuit later. See README.md for examples of what to enter into the paramter `input`.

        &lt;b&gt;inputs&lt;/b&gt; A list of time steps. &lt;br&gt;
        &lt;b&gt;add_gate_name&lt;/b&gt; A label to replace the list of time steps with when the circuit is printed to the terminal using `print_circuit`.&lt;br&gt;
        &#39;&#39;&#39;
        check.check_type(add_gate_name, str)
        self.__validate_gate_logic_inputs(inputs)

        if not add_gate_name == &#34;&#34;: # If defining a gate with a custom Name
            length_of_gate_history = len(self.__gate_history)
            self.__custom_gate_names.append(
                [length_of_gate_history-1, length_of_gate_history + len(inputs), add_gate_name]
            )
        self.__gate_history = self.__gate_history + inputs

    def build_circuit(self) -&gt; MatrixFrame:
        &#39;&#39;&#39;
        Builds the circuit from the gates added via `add_gate_to_circuit` function.

        &lt;b&gt;return&lt;/b&gt; The object specified by the instantiation of the class Dense/Sparse/Lazy object.
        &#39;&#39;&#39;
        self.circuit = self.gate_logic(self.__gate_history)
        return self.circuit</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="QuantumComputerSimulator.QuantumComputer.QuantumComputer"><code class="flex name class">
<span>class <span class="ident">QuantumComputer</span></span>
<span>(</span><span>qubits: int, matrix_type: str = 'Dense')</span>
</code></dt>
<dd>
<div class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p>
<p>Simulates quantum circuits via Dense, Sparse and Lazy methods.</p>
<p><b>qubits</b> Number of qubits in the circuit.<br>
<b>matrix_type</b> Desired implementation of quantum computer to use. Default is Dense.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class QuantumComputer(ABC):

    def __init__(self, qubits: int, matrix_type:str = &#34;Dense&#34;):
        &#39;&#39;&#39;
        Simulates quantum circuits via Dense, Sparse and Lazy methods.

        &lt;b&gt;qubits&lt;/b&gt; Number of qubits in the circuit.&lt;br&gt;
        &lt;b&gt;matrix_type&lt;/b&gt; Desired implementation of quantum computer to use. Default is Dense.
        &#39;&#39;&#39;

        check.check_type(qubits, int)
        self.N = qubits

        check.check_type(matrix_type, str)
        check.check_in_list(matrix_type, [&#34;Dense&#34;, &#34;Sparse&#34;, &#34;Lazy&#34;, &#34;LazySingle&#34;])

        &#39;&#39;&#39;
        Take desired method: Dense, Sparse or Lazy; and set the quantum computer to use that method.
        &#39;&#39;&#39;
        if matrix_type == &#34;Dense&#34;:
            self.Matrix = DenseMatrix
        if matrix_type == &#34;Sparse&#34;:
            self.Matrix = SparseMatrix
        if matrix_type == &#34;Lazy&#34;:
            self.Matrix = LazyMatrix
        if matrix_type == &#34;LazySingle&#34;:
            self.Matrix = LazyMatrixSingle

        &#39;&#39;&#39;
        Build the different gates using the desired method. Gate building is handled within the matrix method.
        &#39;&#39;&#39;
        # single input gates
        self.I = self.Matrix(&#39;I&#39;)
        self.H = self.Matrix(&#39;H&#39;)
        self.P = lambda theta: self.Matrix(&#39;P&#39;, theta)
        self.X = self.Matrix(&#39;X&#39;)
        self.Y = self.Matrix(&#39;Y&#39;)
        self.Z = self.Matrix(&#39;Z&#39;)
        # How does single_gate deal with the extra argument required for P?

        # measuring gates
        self.M0 = self.Matrix(&#39;M0&#39;)
        self.M1 = self.Matrix(&#39;M1&#39;)

        # produce binary digits for 2 input gate logic
        self.binary = self.__produce_digits()

        # gate inputs
        self.single_inputs = [&#34;H&#34;, &#34;P&#34;, &#34;X&#34;, &#34;Y&#34;, &#34;Z&#34;, &#34;M0&#34;, &#34;M1&#34;]
        self.matrices = [self.H, self.P, self.X, self.Y, self.Z, self.M0, self.M1]

        self.double_inputs = [&#34;CV&#34;, &#34;CNOT&#34;, &#34;CZ&#34;]

        #Initalise empty list to store history of gates used.
        self.__gate_history = []
        self.__custom_gate_names = []
        self.circuit = MatrixFrame

    def print_circuit(self):
        &#39;&#39;&#39;
        Prints the circuit that is built from using `add_gate_to_circuit` function.

        WARNING: Need to call `print_circuit_ascii` from terminal/cmd and will clear the terminal screen.
            Prints the quantum circuit in an ascii format on the terminal.
        &#39;&#39;&#39;
        pc = PrintingCircuit(self.__gate_history, self.N, custom_gate_names=self.__custom_gate_names)
        pc.print_circuit_ascii()

    def __produce_digits(self):  # this is the flipped basis, working on
        &#39;&#39;&#39;
        This produces the binary basis needed for the register.
        &#39;&#39;&#39;
        digits = []
        for i in range(0, 2 ** self.N):
            digit = []
            if i &lt; (2 ** self.N) / 2:
                digit.append(0)
            else:
                digit.insert(0, 1)
            for j in range(1, self.N):
                x = i
                for k in range(0, len(digit)):
                    x -= digit[k] * (2 ** self.N) / (2 ** (k + 1))
                if x &lt; (2 ** self.N) / (2 ** (j + 1)):
                    digit.append(0)
                else:
                    digit.append(1)
            digits.append(digit)
        digits = np.flip(digits, axis=1)
        return digits

    def __single_gates(self, gate: list, qnum: list) -&gt; MatrixFrame:
        &#39;&#39;&#39;
        Build the single input gates to a 2^N matrix where N is the number of Qubits.

        &lt;b&gt;gate&lt;/b&gt; A list of gates to build. &lt;br&gt;
        &lt;b&gt;qnum&lt;/b&gt; List of the number of qubits corresponding to each gate.&lt;br&gt;
        &lt;b&gt;return&lt;/b&gt; A gate as the specified matrix object.
        &#39;&#39;&#39;
        M = [0] * self.N

        for i in range(0, len(self.single_inputs)):
            for j in range(0, len(gate)):
                if self.single_inputs[i] == gate[j]:
                    for k in range(0, len(qnum[j])):
                        if gate[j] == &#34;P&#34;:
                            pass
                        else:
                            M[qnum[j][k]] = self.matrices[i]

        for i in range(0, len(M)):
            if type(M[i]) != np.ndarray and type(M[i]) != self.Matrix:
                M[i] = self.I

        m = M[0]
        for i in range(1, len(M)):
            m = self.Matrix.tensor_prod(m, M[i])

        return m

    def __double_gates(self, gate: list, qnum: list) -&gt; MatrixFrame:
        &#39;&#39;&#39;
        Use the Matrix method in the given desired method to build a multi-input gate.

        &lt;b&gt;gate&lt;/b&gt; A list with one elemnt being the double gate. &lt;br&gt;
        &lt;b&gt;qnum&lt;/b&gt; Qubit list. &lt;br&gt;
        &lt;b&gt;return&lt;/b&gt; Returns correctly sized multi-input gate.
        &#39;&#39;&#39;
        if gate[0] == &#34;CV&#34;:
            return self.Matrix(&#34;CV&#34;, self.binary, qnum[0][0], qnum[0][1])
        if gate[0] == &#34;CNOT&#34;:
            return self.Matrix(&#34;CNOT&#34;, self.binary, qnum[0][0], qnum[0][1])
        if gate[0] == &#34;CZ&#34;:
            return self.Matrix(&#34;CZ&#34;, self.binary, qnum[0][0], qnum[0][1])

    def __validate_gate_logic_inputs(self, inputs: list):
        &#39;&#39;&#39;
        A custom check function to verify the list of time steps when the user is adding gates to the circuit.
        &#39;&#39;&#39;
        check.check_type(inputs, list)

        for time_step in inputs:
            check.check_type(time_step, tuple)
            check.check_array_length(time_step, 2)
            check.check_type(time_step[0], list)
            check.check_type(time_step[1], list)
            check.check_array_length(time_step[0], len(time_step[1]))
            for gate in time_step[0]: #Looping through gates, check to see they&#39;re recognisable.
                check.check_type(gate, str)
                check.check_in_list(gate, self.single_inputs + self.double_inputs)
            for gate_positions in time_step[1]:
                check.check_type(gate_positions, list)
                for numbers in gate_positions:
                    check.check_type(numbers, int)

    def gate_logic(self, inputs: list, add_gate_name: str = &#34;&#34;) -&gt; MatrixFrame:
        &#39;&#39;&#39;
        Builds the quantum circuit from a list of time steps. See README.md for examples of what to enter into the parameter `input`.

        &lt;b&gt;inputs&lt;/b&gt; List of time steps. &lt;br&gt;
        &lt;b&gt;add_gate_name&lt;/b&gt; Name of gates to be added. &lt;br&gt;
        &lt;b&gt;return&lt;/b&gt; The circuit of type determined from the instantiation of quantum computer.
        &#39;&#39;&#39;

        check.check_type(add_gate_name, str)
        self.__validate_gate_logic_inputs(inputs)

        step_n = len(inputs)

        M = []

        for i in range(0, step_n):
            gate_type = []
            for j in range(0, len(self.single_inputs)):
                if self.single_inputs[j] in inputs[i][0]:
                    gate_type.append(&#39;single&#39;)

            for j in range(0, len(self.double_inputs)):
                if self.double_inputs[j] in inputs[i][0]:
                    gate_type.append(&#39;double&#39;)

            gate_single = []
            gate_double = []
            for j in range(0, len(gate_type)):
                if gate_type[j] == &#39;single&#39;:
                    gate_single.append(True)
                else:
                    gate_single.append(False)
                if gate_type[j] == &#39;double&#39;:
                    gate_double.append(True)
                else:
                    gate_double.append(False)

            if all(gate_single) == True:
                M.append(self.__single_gates(inputs[i][0], inputs[i][1]))
            elif all(gate_double) == True:
                M.append(self.__double_gates(inputs[i][0], inputs[i][1]))
            else:
                print(
                    &#34;Input error: single gates and double gates must be in separate steps. Returning identity matrix instead.&#34;)
                return self.Matrix(&#39;I&#39;)

        M = np.flip(M, axis=0)
        m = M[0]
        for i in range(1, len(M)):
            m = self.Matrix.matrix_multiply(m, M[i])

        return m

    def measure_any(self, qnum: int, state: int, register: list) -&gt; int:
        &#39;&#39;&#39;
        Generate the measurement of the quantum circuit; once measured the system&#39;s wave function is collapsed.

        &lt;b&gt;qnum&lt;/b&gt; Number of qubits. &lt;br&gt;
        &lt;b&gt;state&lt;/b&gt; State of the qubit. &lt;br&gt;
        &lt;b&gt;state&lt;/b&gt; Result of the measurement of qubit qnum.
        &#39;&#39;&#39;
        check.check_type(qnum, int)
        check.check_type(state, int)
        check.check_type(register, list)

        inner_register = self.Matrix.inner_product(register)
        if state == 0:
            matrix = self.__single_gates([&#34;M0&#34;], [[qnum]])
        elif state == 1:
            matrix = self.__single_gates([&#34;M1&#34;], [[qnum]])

        QP = self.Matrix.trace(self.Matrix.matrix_multiply(matrix, inner_register))
        #print(&#39;QP= &#39;, QP)
        if (np.random.rand() &lt; QP):
            result = 0
        else:
            result = 1
        return result

    def apply_register_and_measure(self, repeats: int = 1000, user_input_vector: list = []) -&gt; dict:
        &#39;&#39;&#39;
        Apply&#39;s a register to the circuit built with `add_gate_to_circuit`, with default being the |0&gt; state in the computatinal basis.

        &lt;b&gt;repeats&lt;/b&gt; The number of measurements to be taken; assuming upon each measurement a new register is applied. &lt;br&gt;
        &lt;b&gt;user_input_vector&lt;/b&gt; Allows custom choice of a register. &lt;br&gt;
        &lt;b&gt;returns&lt;/b&gt; A dictionary of keys labelling the binary states, and the values the number of times that state was measured over.
        &#39;&#39;&#39;
        check.check_type(repeats, int)

        # Checks to see if user has defined their own register. If so, switch to theirs and validate
        input_vector = np.zeros(2**self.N)
        input_vector[0] = 1
        if not user_input_vector == []:
            check.check_type(user_input_vector, list)
            check.check_array_shape(user_input_vector, (2**self.N))
            check.check_sum(user_input_vector, 1.00) # Check normalisation.
            input_vector = user_input_vector

        probabilities = self.circuit.apply_register(input_vector) #Get probabilities from applying input vector

        binary_states = {}
        for i, basis in enumerate(self.binary):
            binary_states[&#39;&#39;.join([str(j) for j in basis[::-1]])] = 0 # Creates the binary label, such as 001 for |001&gt;.


        keys_list = list(binary_states.keys())
        for _ in range(repeats): # Repeats the measurements a number of times
            cumulative = 0
            skip = False
            j = 0
            random_var = random.random()
            while (not skip) and j &lt; len(probabilities): # From random number between 0 and 1, finds the component of the vector by cummulative probability.
                cumulative += probabilities[j]
                if cumulative &gt; random_var:
                    binary_states[keys_list[j]] += 1
                    skip = True
                j += 1

        return binary_states

    def add_gate_to_circuit(self, inputs: list, add_gate_name:str = &#34;&#34;):
        &#39;&#39;&#39;
        Adds the gates to the class ready to for building the circuit later. See README.md for examples of what to enter into the paramter `input`.

        &lt;b&gt;inputs&lt;/b&gt; A list of time steps. &lt;br&gt;
        &lt;b&gt;add_gate_name&lt;/b&gt; A label to replace the list of time steps with when the circuit is printed to the terminal using `print_circuit`.&lt;br&gt;
        &#39;&#39;&#39;
        check.check_type(add_gate_name, str)
        self.__validate_gate_logic_inputs(inputs)

        if not add_gate_name == &#34;&#34;: # If defining a gate with a custom Name
            length_of_gate_history = len(self.__gate_history)
            self.__custom_gate_names.append(
                [length_of_gate_history-1, length_of_gate_history + len(inputs), add_gate_name]
            )
        self.__gate_history = self.__gate_history + inputs

    def build_circuit(self) -&gt; MatrixFrame:
        &#39;&#39;&#39;
        Builds the circuit from the gates added via `add_gate_to_circuit` function.

        &lt;b&gt;return&lt;/b&gt; The object specified by the instantiation of the class Dense/Sparse/Lazy object.
        &#39;&#39;&#39;
        self.circuit = self.gate_logic(self.__gate_history)
        return self.circuit</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="QuantumComputerSimulator.QuantumComputer.QuantumComputer.add_gate_to_circuit"><code class="name flex">
<span>def <span class="ident">add_gate_to_circuit</span></span>(<span>self, inputs: list, add_gate_name: str = '')</span>
</code></dt>
<dd>
<div class="desc"><p>Adds the gates to the class ready to for building the circuit later. See README.md for examples of what to enter into the paramter <code>input</code>.</p>
<p><b>inputs</b> A list of time steps. <br>
<b>add_gate_name</b> A label to replace the list of time steps with when the circuit is printed to the terminal using <code>print_circuit</code>.<br></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_gate_to_circuit(self, inputs: list, add_gate_name:str = &#34;&#34;):
    &#39;&#39;&#39;
    Adds the gates to the class ready to for building the circuit later. See README.md for examples of what to enter into the paramter `input`.

    &lt;b&gt;inputs&lt;/b&gt; A list of time steps. &lt;br&gt;
    &lt;b&gt;add_gate_name&lt;/b&gt; A label to replace the list of time steps with when the circuit is printed to the terminal using `print_circuit`.&lt;br&gt;
    &#39;&#39;&#39;
    check.check_type(add_gate_name, str)
    self.__validate_gate_logic_inputs(inputs)

    if not add_gate_name == &#34;&#34;: # If defining a gate with a custom Name
        length_of_gate_history = len(self.__gate_history)
        self.__custom_gate_names.append(
            [length_of_gate_history-1, length_of_gate_history + len(inputs), add_gate_name]
        )
    self.__gate_history = self.__gate_history + inputs</code></pre>
</details>
</dd>
<dt id="QuantumComputerSimulator.QuantumComputer.QuantumComputer.apply_register_and_measure"><code class="name flex">
<span>def <span class="ident">apply_register_and_measure</span></span>(<span>self, repeats: int = 1000, user_input_vector: list = []) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>Apply's a register to the circuit built with <code>add_gate_to_circuit</code>, with default being the |0&gt; state in the computatinal basis.</p>
<p><b>repeats</b> The number of measurements to be taken; assuming upon each measurement a new register is applied. <br>
<b>user_input_vector</b> Allows custom choice of a register. <br>
<b>returns</b> A dictionary of keys labelling the binary states, and the values the number of times that state was measured over.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply_register_and_measure(self, repeats: int = 1000, user_input_vector: list = []) -&gt; dict:
    &#39;&#39;&#39;
    Apply&#39;s a register to the circuit built with `add_gate_to_circuit`, with default being the |0&gt; state in the computatinal basis.

    &lt;b&gt;repeats&lt;/b&gt; The number of measurements to be taken; assuming upon each measurement a new register is applied. &lt;br&gt;
    &lt;b&gt;user_input_vector&lt;/b&gt; Allows custom choice of a register. &lt;br&gt;
    &lt;b&gt;returns&lt;/b&gt; A dictionary of keys labelling the binary states, and the values the number of times that state was measured over.
    &#39;&#39;&#39;
    check.check_type(repeats, int)

    # Checks to see if user has defined their own register. If so, switch to theirs and validate
    input_vector = np.zeros(2**self.N)
    input_vector[0] = 1
    if not user_input_vector == []:
        check.check_type(user_input_vector, list)
        check.check_array_shape(user_input_vector, (2**self.N))
        check.check_sum(user_input_vector, 1.00) # Check normalisation.
        input_vector = user_input_vector

    probabilities = self.circuit.apply_register(input_vector) #Get probabilities from applying input vector

    binary_states = {}
    for i, basis in enumerate(self.binary):
        binary_states[&#39;&#39;.join([str(j) for j in basis[::-1]])] = 0 # Creates the binary label, such as 001 for |001&gt;.


    keys_list = list(binary_states.keys())
    for _ in range(repeats): # Repeats the measurements a number of times
        cumulative = 0
        skip = False
        j = 0
        random_var = random.random()
        while (not skip) and j &lt; len(probabilities): # From random number between 0 and 1, finds the component of the vector by cummulative probability.
            cumulative += probabilities[j]
            if cumulative &gt; random_var:
                binary_states[keys_list[j]] += 1
                skip = True
            j += 1

    return binary_states</code></pre>
</details>
</dd>
<dt id="QuantumComputerSimulator.QuantumComputer.QuantumComputer.build_circuit"><code class="name flex">
<span>def <span class="ident">build_circuit</span></span>(<span>self) ‑> <a title="QuantumComputerSimulator.mods.MatrixFrame.MatrixFrame" href="mods/MatrixFrame.html#QuantumComputerSimulator.mods.MatrixFrame.MatrixFrame">MatrixFrame</a></span>
</code></dt>
<dd>
<div class="desc"><p>Builds the circuit from the gates added via <code>add_gate_to_circuit</code> function.</p>
<p><b>return</b> The object specified by the instantiation of the class Dense/Sparse/Lazy object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def build_circuit(self) -&gt; MatrixFrame:
    &#39;&#39;&#39;
    Builds the circuit from the gates added via `add_gate_to_circuit` function.

    &lt;b&gt;return&lt;/b&gt; The object specified by the instantiation of the class Dense/Sparse/Lazy object.
    &#39;&#39;&#39;
    self.circuit = self.gate_logic(self.__gate_history)
    return self.circuit</code></pre>
</details>
</dd>
<dt id="QuantumComputerSimulator.QuantumComputer.QuantumComputer.gate_logic"><code class="name flex">
<span>def <span class="ident">gate_logic</span></span>(<span>self, inputs: list, add_gate_name: str = '') ‑> <a title="QuantumComputerSimulator.mods.MatrixFrame.MatrixFrame" href="mods/MatrixFrame.html#QuantumComputerSimulator.mods.MatrixFrame.MatrixFrame">MatrixFrame</a></span>
</code></dt>
<dd>
<div class="desc"><p>Builds the quantum circuit from a list of time steps. See README.md for examples of what to enter into the parameter <code>input</code>.</p>
<p><b>inputs</b> List of time steps. <br>
<b>add_gate_name</b> Name of gates to be added. <br>
<b>return</b> The circuit of type determined from the instantiation of quantum computer.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gate_logic(self, inputs: list, add_gate_name: str = &#34;&#34;) -&gt; MatrixFrame:
    &#39;&#39;&#39;
    Builds the quantum circuit from a list of time steps. See README.md for examples of what to enter into the parameter `input`.

    &lt;b&gt;inputs&lt;/b&gt; List of time steps. &lt;br&gt;
    &lt;b&gt;add_gate_name&lt;/b&gt; Name of gates to be added. &lt;br&gt;
    &lt;b&gt;return&lt;/b&gt; The circuit of type determined from the instantiation of quantum computer.
    &#39;&#39;&#39;

    check.check_type(add_gate_name, str)
    self.__validate_gate_logic_inputs(inputs)

    step_n = len(inputs)

    M = []

    for i in range(0, step_n):
        gate_type = []
        for j in range(0, len(self.single_inputs)):
            if self.single_inputs[j] in inputs[i][0]:
                gate_type.append(&#39;single&#39;)

        for j in range(0, len(self.double_inputs)):
            if self.double_inputs[j] in inputs[i][0]:
                gate_type.append(&#39;double&#39;)

        gate_single = []
        gate_double = []
        for j in range(0, len(gate_type)):
            if gate_type[j] == &#39;single&#39;:
                gate_single.append(True)
            else:
                gate_single.append(False)
            if gate_type[j] == &#39;double&#39;:
                gate_double.append(True)
            else:
                gate_double.append(False)

        if all(gate_single) == True:
            M.append(self.__single_gates(inputs[i][0], inputs[i][1]))
        elif all(gate_double) == True:
            M.append(self.__double_gates(inputs[i][0], inputs[i][1]))
        else:
            print(
                &#34;Input error: single gates and double gates must be in separate steps. Returning identity matrix instead.&#34;)
            return self.Matrix(&#39;I&#39;)

    M = np.flip(M, axis=0)
    m = M[0]
    for i in range(1, len(M)):
        m = self.Matrix.matrix_multiply(m, M[i])

    return m</code></pre>
</details>
</dd>
<dt id="QuantumComputerSimulator.QuantumComputer.QuantumComputer.measure_any"><code class="name flex">
<span>def <span class="ident">measure_any</span></span>(<span>self, qnum: int, state: int, register: list) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Generate the measurement of the quantum circuit; once measured the system's wave function is collapsed.</p>
<p><b>qnum</b> Number of qubits. <br>
<b>state</b> State of the qubit. <br>
<b>state</b> Result of the measurement of qubit qnum.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def measure_any(self, qnum: int, state: int, register: list) -&gt; int:
    &#39;&#39;&#39;
    Generate the measurement of the quantum circuit; once measured the system&#39;s wave function is collapsed.

    &lt;b&gt;qnum&lt;/b&gt; Number of qubits. &lt;br&gt;
    &lt;b&gt;state&lt;/b&gt; State of the qubit. &lt;br&gt;
    &lt;b&gt;state&lt;/b&gt; Result of the measurement of qubit qnum.
    &#39;&#39;&#39;
    check.check_type(qnum, int)
    check.check_type(state, int)
    check.check_type(register, list)

    inner_register = self.Matrix.inner_product(register)
    if state == 0:
        matrix = self.__single_gates([&#34;M0&#34;], [[qnum]])
    elif state == 1:
        matrix = self.__single_gates([&#34;M1&#34;], [[qnum]])

    QP = self.Matrix.trace(self.Matrix.matrix_multiply(matrix, inner_register))
    #print(&#39;QP= &#39;, QP)
    if (np.random.rand() &lt; QP):
        result = 0
    else:
        result = 1
    return result</code></pre>
</details>
</dd>
<dt id="QuantumComputerSimulator.QuantumComputer.QuantumComputer.print_circuit"><code class="name flex">
<span>def <span class="ident">print_circuit</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Prints the circuit that is built from using <code>add_gate_to_circuit</code> function.</p>
<p>WARNING: Need to call <code>print_circuit_ascii</code> from terminal/cmd and will clear the terminal screen.
Prints the quantum circuit in an ascii format on the terminal.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def print_circuit(self):
    &#39;&#39;&#39;
    Prints the circuit that is built from using `add_gate_to_circuit` function.

    WARNING: Need to call `print_circuit_ascii` from terminal/cmd and will clear the terminal screen.
        Prints the quantum circuit in an ascii format on the terminal.
    &#39;&#39;&#39;
    pc = PrintingCircuit(self.__gate_history, self.N, custom_gate_names=self.__custom_gate_names)
    pc.print_circuit_ascii()</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="QuantumComputerSimulator" href="index.html">QuantumComputerSimulator</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="QuantumComputerSimulator.QuantumComputer.QuantumComputer" href="#QuantumComputerSimulator.QuantumComputer.QuantumComputer">QuantumComputer</a></code></h4>
<ul class="">
<li><code><a title="QuantumComputerSimulator.QuantumComputer.QuantumComputer.add_gate_to_circuit" href="#QuantumComputerSimulator.QuantumComputer.QuantumComputer.add_gate_to_circuit">add_gate_to_circuit</a></code></li>
<li><code><a title="QuantumComputerSimulator.QuantumComputer.QuantumComputer.apply_register_and_measure" href="#QuantumComputerSimulator.QuantumComputer.QuantumComputer.apply_register_and_measure">apply_register_and_measure</a></code></li>
<li><code><a title="QuantumComputerSimulator.QuantumComputer.QuantumComputer.build_circuit" href="#QuantumComputerSimulator.QuantumComputer.QuantumComputer.build_circuit">build_circuit</a></code></li>
<li><code><a title="QuantumComputerSimulator.QuantumComputer.QuantumComputer.gate_logic" href="#QuantumComputerSimulator.QuantumComputer.QuantumComputer.gate_logic">gate_logic</a></code></li>
<li><code><a title="QuantumComputerSimulator.QuantumComputer.QuantumComputer.measure_any" href="#QuantumComputerSimulator.QuantumComputer.QuantumComputer.measure_any">measure_any</a></code></li>
<li><code><a title="QuantumComputerSimulator.QuantumComputer.QuantumComputer.print_circuit" href="#QuantumComputerSimulator.QuantumComputer.QuantumComputer.print_circuit">print_circuit</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>